# Playwright DOM Extractor - Demo Script

This script provides a step-by-step guide for demonstrating the capabilities of the Playwright DOM Extractor tool in a live presentation.

## Setup Before Presentation

1. Clone the repository to your local machine:
   ```bash
   git clone https://github.com/Kamenorite/playwright-dom-extractor.git
   cd playwright-dom-extractor
   npm install
   ```

2. Ensure Cursor MCP is properly configured:
   - Verify `.cursor/mcp.json` exists and contains the correct configuration
   - Ensure Cursor is running and MCP integration is active

3. Check that all demo HTML files are in place:
   - Verify `test-html/data-testid-demo.html` exists

4. Open these terminal windows/tabs:
   - One in the project root directory for running commands
   - One ready to open JSON/HTML files from the mappings directory
   - One ready to demonstrate the generated files

5. Test the demo script in advance to ensure everything works as expected

## Demo Flow

### Introduction (2 minutes)

1. Introduce yourself and the purpose of the presentation
2. Briefly explain what Playwright DOM Extractor is and why it was created
3. Show the GitHub repository to set the context
4. Outline what you'll be demonstrating

### Demo 1: System Architecture and Component Interactions (3 minutes)

1. Display the system architecture diagram and explain:
   ```bash
   open presentation/reveal/architecture-diagram.png # Or equivalent for your OS
   ```

2. Walk through the key components and their interactions:
   - **DOM Monitor**: Extracts elements from web pages
   - **Semantic Helper**: Provides natural language matching
   - **MCP AI Service**: Generates semantic keys and alternative names
   - **Mapping Files**: Store element information for lookup

3. Explain the data flow between components:
   - How test scripts use `getByDescription` to find elements
   - How semantic helper searches mapping files for matches
   - How DOM Monitor creates the mapping files
   - How MCP AI Service enhances the semantic keys

4. Show key files that implement these components:
   ```bash
   ls -la utils/semantic-helper.ts
   ls -la dom-monitor.ts
   ls -la services/mcp-ai-service.ts
   ```

### Demo 2: Basic DOM Extraction (4 minutes)

1. Start by showing the interactive CLI:
   ```bash
   npm run cli
   ```

2. When prompted:
   - Choose "Extract DOM from a URL"
   - Enter the URL: `https://example.com`
   - Choose "Basic (Rule-based)" for semantic key generation
   - Output directory: `./mappings`
   - Feature name: `demo`
   - Take screenshot: Yes
   - Wait for selector: (leave empty)
   - Wait timeout: 5000 (default)

3. Show the generated files:
   ```bash
   ls -la mappings/
   ```

4. Open and explain the JSON file:
   ```bash
   cat mappings/demo_example_com_.json | head -n 20
   ```

5. Open the HTML report in your browser:
   ```bash
   open mappings/demo_example_com_.html  # On macOS
   # or
   xdg-open mappings/demo_example_com_.html  # On Linux
   # or
   start mappings/demo_example_com_.html  # On Windows
   ```

6. In the HTML report, highlight:
   - The interactive filtering capabilities
   - Element details and their attributes
   - The suggested Playwright selectors
   - The semantically generated keys

### Demo 3: AI-Powered Extraction with MCP (4 minutes)

1. Return to the interactive CLI:
   ```bash
   npm run cli
   ```

2. When prompted:
   - Choose "Extract DOM from a URL"
   - Enter the URL: `https://hivebrite.io` (or another more complex site)
   - Choose "AI-powered (via MCP)" for semantic key generation
   - Output directory: `./mappings`
   - Feature name: `ai_demo`
   - Take screenshot: Yes
   - Wait for selector: (leave empty)
   - Wait timeout: 5000 (default)

3. While it's running, explain:
   - How MCP integration works
   - The advantages of AI-powered semantic key generation
   - How it's using Cursor's AI capabilities without API keys

4. Compare the AI-generated keys with the basic ones:
   ```bash
   grep "semanticKey" mappings/demo_example_com_.json | head -n 10
   grep "semanticKey" mappings/ai_demo_hivebrite_io_.json | head -n 10
   ```

5. Show the alternative names generated by AI:
   ```bash
   grep -A 10 "alternativeNames" mappings/ai_demo_hivebrite_io_.json | head -n 15
   ```

6. Explain how these alternative names enhance matching flexibility

### Demo 4: Natural Language Description Matching (4 minutes)

1. Show the demo test script:
   ```bash
   cat presentation/demo-test.ts
   ```

2. Explain key parts of the test:
   - How the `getByDescription` function works
   - How natural language descriptions are matched to elements
   - The improved readability of tests using descriptions

3. Run the test to demonstrate it in action:
   ```bash
   npx playwright test presentation/demo-test.ts
   ```

4. Show the test results and the interaction with elements:
   - Point out how elements are identified by natural language
   - Show how different descriptions match to the same element

5. Explain the matching process under the hood:
   - Loading mapping files
   - Scoring elements based on their match to descriptions
   - Selecting the best match
   - Converting to a Playwright locator

### Demo 5: Ambiguity Detection (5 minutes)

1. Introduce the ambiguity detection demo:
   ```bash
   cat examples/ambiguity-detection-demo.ts
   ```

2. Explain the key features:
   - How it detects when descriptions match multiple elements
   - How it suggests more specific descriptions
   - How it enforces feature specification when needed

3. Run the ambiguity detection demo:
   ```bash
   npx ts-node examples/ambiguity-detection-demo.ts
   ```

4. Interact with the demo by entering these descriptions:
   - `todo item` (will show ambiguity warning)
   - `delete button` (will show ambiguity warning)
   - `buy milk item` (should be unique)
   - `checkbox` (will show ambiguity warning)

5. Show the output when ambiguity is detected:
   - Warning about multiple matching elements
   - Scores for each potential match
   - Suggestions for more specific descriptions
   - Feature context recommendations

6. Explain how this improves test reliability:
   - Prevents flaky tests due to ambiguous selectors
   - Guides developers to use more specific descriptions
   - Enforces uniqueness when needed
   - Reduces maintenance burdens

### Demo 6: Data-testid Prioritization (3 minutes)

1. First, show the demo HTML file that contains data-testid attributes:
   ```bash
   cat test-html/data-testid-demo.html | grep -A 2 data-testid
   ```

2. Extract DOM elements from this local file using the CLI or direct command:
   ```bash
   npm run monitor-page -- --url file://$(pwd)/test-html/data-testid-demo.html --feature testid_demo
   ```

3. Examine the results:
   ```bash
   cat mappings/testid_demo_*.json | grep -A 5 "data-testid"
   ```

4. Show how the generated selectors prioritize data-testid:
   - Open the HTML report
   - Filter for elements with data-testid
   - Point out how the suggested selectors use data-testid instead of ID or XPath

5. Explain the advantages of using data-testid:
   - Resilience to UI changes
   - Explicit testing intent
   - Better performance than complex XPath expressions

### Conclusion and Advanced Features (2 minutes)

1. Summarize the key benefits demonstrated:
   - Natural language element selection
   - Component interactions that provide flexibility
   - Ambiguity detection for reliable tests
   - AI integration for better semantic keys
   - Improved test stability and readability

2. Briefly mention additional features:
   - Mapping file management
   - Test generation capabilities
   - Integration with CI/CD pipelines
   - Additional configuration options

3. Show resources for additional information:
   - GitHub repository
   - README.md
   - BEST-PRACTICES.md
   - MCP-INTEGRATION.md

### Q&A (5 minutes)

Be prepared to answer questions about:
- Installation and setup
- Integration with existing test suites
- Customization options
- Handling dynamic content
- Performance considerations
- Using with different frameworks

## Post-Demo Cleanup

1. Clean up any generated files if needed:
   ```bash
   rm -rf mappings/demo_* mappings/ai_demo_* mappings/testid_demo_*
   ```

2. Close all opened files and browsers

3. Push any changes made during the demo to GitHub if appropriate 